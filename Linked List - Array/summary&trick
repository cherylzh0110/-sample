1.reverse link:
remember:
ListNode cur = head;
        ListNode pre=null;
        while(cur!=null){
            ListNode temp=cur.next;
            cur.next=pre;
            pre=cur;
            cur=temp;
        }
        
example of linkedlist: 
Reverse nodes in k-groups: leetcode 25
Copy List with Random Pointer:  leetcode 138
Linked List Cycle: linkedlist cycle 141 142. for 142, need to remember the trick

        
        
        
        
        
array:

Arrays.sort(): is quick sort
time:O(nlogn)  space:O(1)
merge sorted array:

median of two sorted array: leetcode 4


subarray 类型:
trick:
子数组 Subarray
令 PrefixSum[i] = A[0] + A[1] + ... A[i - 1], PrefixSum[0] = 0 易知构造 PrefixSum 耗费 O(n) 时间和 O(n) 空间
如需计算子数组从下标i到下标j之间的所有数之和
则有 Sum(i~j) = PrefixSum[j + 1] - PrefixSum[i]

example: 
Subarray Sum Equals K: leetcode 560

subarray sum closes: linkcode 还未看
