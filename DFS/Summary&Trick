for solving the solution:
  draw the DFS tree first

partition:
Matchsticks to Square: lc 473
Palindrome Partitioning: lc 131

search in graph: 
trick: 
1.在matrix中搜索四个方向时，设两个数组有时候可以简化代码
    int[] dx = {-1, 1, 0, 0};
    int[] dy = {0, 0, -1, 1};
     for(int i = 0; i < 4; i++){
        int nextX = point.x + dx[i];
        int nextY = point.y + dy[i];
        ...
     }
      用visited[][]数组来去重时候，如果是单纯的DFS访问所有节点（每个节点只能访问一次），那么不需要将visited还原， 如果DFS的每个分支可能访问
      相同的节点（如 word searchII），那么在每个节点search完以后要将visited还原。如：
      visited[x][y]=true;                // be careful when to set the visited
        if(obj.search(s)){
            if(!res.contains(s))
                res.add(s);
        }
        if(obj.startsWith(s)){
            for(int i=0;i<4;i++){
                traverse(res,obj,board,visited,s,x+c1[i],y+c2[i]);
            }
        }
        visited[x][y]=false;      // be careful when to recover the visited
 2.画dfs的搜索树的时候如果有很多的节点是相等的，就可以考虑memorization
        
        
      
word ladder I II: lc 126 & 127
word search: lc 79

combination: 通常画个tree来帮助思考
Combinations: lc 77

question that need to improve the time complextiy using cached (DP): 
Longest Increasing Path in a Matrix:lc 329 (this is a sample using memorization!!!!!!!!!);
Out of Boundary Paths:lc 576 (classical question using with memorization.)


