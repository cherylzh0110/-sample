Summary&Trick

   1
  2 3
 4 5
• Preorder 前序遍历       
  • 12453根左右
• Inorder 中序遍历 
  • 42513左根右
• Postorder 后序遍历
  • 45231左右根
  背：preorder 和 inorder: this.preorder  this.inorder
• Traverse vs Divide Conquer
  • They are both Recursion Algorithm
  • Result in parameter vs Result in return value 
  • Top down vs Bottom up
  
  

  
Trick:

1.For Divide Conquer, often create a resultType class, to easily store the current state variables(if we need more than 1 variable).
Refer the question Balanced Binary Tree.

2.For the questions that need maximum/minimum value, we need to use traverse or traverse combine divide_conquer, using a global
variable to store and compare the value. 
related questions:
Largest BST Subtree: lc 333

3.according to the output order, we can think about using pre, in, post order, or using BFS for level order.



questions about level traverse:
Maximum Width of Binary Tree: lc 622
 Binary Tree Vertical Order Traversal: lc314 好题！能拓展思路



preorder:
Verify Preorder Sequence in Binary Search Tree:lc 255


BST
property: inorder traversal is non-decreasing. Can use it to check BST.

For Preorder and Inorder traverse, recite the stack solution.

Delete Node in BST: LC450

Verify Preorder Sequence in Binary Search Tree： lc255 注意stack的解法。divide conquer解法太难想到。
Inorder Successor in BST: lc285。 using divide conquer. A little trick (need to review) but very good question to learn divide conquer.

Split BST: lc776 using divide&conquer. tricky.


Divide Conquer non tree question:
Different Ways to Add Parentheses: lc241 经典！


