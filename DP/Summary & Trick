Triangle: Leetcode 120  Divide Conquer + Memorization = dp

什么情况下使用动态规划：
满足下面三个条件之一：
1 求最大值最小值
2 判断是否可行
3 统计方案个数
则极有可能是使用动态规划


分类：
坐标型动态规划
Minimum Path Sum: lc 64. 
unique path: lc 62 63
Climbing Stairs: lc 70

接龙型动态规划: 当前状态与之前的状态有联系，找到这个联系后，考虑是否需要寻找到一个最大或最小值。（也是一种坐标型）
Longest Increasing Subsequence: lc300, use dp cost O(n^2), use binary seach cost(nlogn) 
Largest Divisible Subset: lc368  cost O(n^2). sometimes if we want to output the result, we can use an array to store last state
of dp.(保存上一个状态).  compare lc300 and lc368, both need to find the minimum or maximum value from the state before. 

Russian Doll Envelopes: lc354

序列型动态规划： 这类题目特点
• f[i] = max(f[i-1], f[i-2] + A[i]); 由 f[i-1],f[i-2] 来决定状态， 不再是找前面状态的最大或最小值。
House Robber: lc198 lc213
Maximal Square: lc 221. 

记忆化搜索（memorization):
Longest Increasing Continuous subsequence II: (结合了dfs和dp， 帮助理解dp如何在搜索的过程中去重，大大降低算法的时间复杂度。）此题只有记忆
化搜索才能最优化。
https://algorithm.yuanbin.me/zh-hans/dynamic_programming/longest_increasing_continuous_subsequence_ii.html

什么时候用记忆化搜索? 
1. 状态转移特别麻烦，不是顺序性。
2. 初始化状态不是很容易找到。
 
博弈dp：用搜索的角度去找状态之间的关系。
this.coin in the line





