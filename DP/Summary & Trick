Triangle: Leetcode 120  Divide Conquer + Memorization = dp

什么情况下使用动态规划：
满足下面三个条件之一：
1 求最大值最小值
2 判断是否可行
3 统计方案个数
则极有可能是使用动态规划


分类：
坐标型动态规划
Minimum Path Sum: lc 64. 
unique path: lc 62 63
Climbing Stairs: lc 70

接龙型动态规划: 当前状态与之前的状态有联系，找到这个联系后，考虑是否需要寻找到一个最大或最小值。（也是一种坐标型）
Longest Increasing Subsequence: lc300, use dp cost O(n^2), use binary seach cost(nlogn) 
Largest Divisible Subset: lc368  cost O(n^2). sometimes if we want to output the result, we can use an array to store last state
of dp.(保存上一个状态).  compare lc300 and lc368, both need to find the minimum or maximum value from the state before. 

Russian Doll Envelopes: lc354

序列型动态规划： 这类题目特点
• f[i] = max(f[i-1], f[i-2] + A[i]); 由 f[i-1],f[i-2] 来决定状态， 不再是找前面状态的最大或最小值。
Trick: 
1.有时候注意判断dp，可能是i+1，也可能是i-1
House Robber: lc198 lc213
Maximal Square: lc 221. 
Delete and Earn: lc 740. similar to house robber.
Dungeon Game: lc 174.  this is special because dp direction is different from other questions. 

记忆化搜索（memorization):
Longest Increasing Continuous subsequence II: (结合了dfs和dp， 帮助理解dp如何在搜索的过程中去重，大大降低算法的时间复杂度。）此题只有记忆
化搜索才能最优化。
https://algorithm.yuanbin.me/zh-hans/dynamic_programming/longest_increasing_continuous_subsequence_ii.html
Longest Increasing Path in a Matrix:lc 329! (自己写的模板，复习时候看!)
Combination Sum IV:lc377 这道题题目类似于背包问题，但是由于顺序不同，结果也不同，所以难以写出递推公式，用memorization却能轻易解决。

什么时候用记忆化搜索? 
1. 状态转移特别麻烦，不是顺序性。
2. 初始化状态不是很容易找到。
 
博弈dp：用搜索的角度去找状态之间的关系 (可以用memorization 写，也可以用普通写法）。
this.coin in the line |, ||

区间型dp: 
Burst Balloons: lc 312 (注意for循环的顺序，是个套路）
Palindromic Substrings: lc647
Longest Palindromic Substring: lc5 (这道题只有设成区间型(i,j)，才能写出递推公式）

匹配型dp: input is almost two string. 
this. longest common subsequence
Edit Distance: lc 72
Distinct Subsequences: lc 115 
Interleaving String: lc 97(未完成）
a trick for writing code is that if input is string, the length of dp array should be str.length+1;

背包类dp：
Coin Change: lc322 lc518
Ones and Zeroes: lc474

大类型DP（自己总结）: 如果只和上一个状态有关系，怎么space complexity可以降低为O(1)
Best Time to Buy and Sell Stock:

T[i][k][0](ending in ith index and at most k!!!(at most is important) transaction ending in 0 stock),  
T[i][k][1] (ending in ith index and at most k!!!(at most is important) transaction ending in 1 stock);
Base cases:
T[-1][k][0] = 0, T[-1][k][1] = -Infinity
T[i][0][0] = 0, T[i][0][1] = -Infinity

Recurrence relation:
T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])
T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i])

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870




