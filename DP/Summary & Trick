Triangle: Leetcode 120  Divide Conquer + Memorization = dp

什么情况下使用动态规划：
满足下面三个条件之一：
1 求最大值最小值
2 判断是否可行
3 统计方案个数
则极有可能是使用动态规划
• 动态规划擅长与优化指数级别复杂度(2^n,n!)到多项式级别复杂度(n^2,n^3) 
• 不擅长优化n^3到n^2


分类：
坐标型动态规划
Minimum Path Sum: lc 64. 
unique path: lc 62 63
Climbing Stairs: lc 70

接龙型动态规划: 当前状态与之前的状态有联系，找到这个联系后，考虑是否需要寻找到一个最大或最小值。（也是一种坐标型） 有时候上一个状态与dp[i-j]有关系
Longest Increasing Subsequence: lc300, use dp cost O(n^2), use binary seach cost(nlogn) 
Largest Divisible Subset: lc368  cost O(n^2). sometimes if we want to output the result, we can use an array to store last state
of dp.(保存上一个状态).  compare lc300 and lc368, both need to find the minimum or maximum value from the state before. 
Palindrome Partitioning II： lc132. 注意这道题为什么不设置成区间dp[i][j]的原因，从而降低时间复杂度。

Russian Doll Envelopes: lc354

序列型动态规划： 这类题目特点
• f[i] = max(f[i-1], f[i-2] + A[i]); 由 f[i-1],f[i-2] 来决定状态， 不再是找前面状态的最大或最小值。
Trick: 
1.有时候注意判断dp，可能是i+1，也可能是i-1
2.有时候要考虑上一个情况（i-1）的分情况讨论，
3.经常要判断上一个状态是否包括了更之前的状态
House Robber: lc198 lc213 lc337(有技巧）
Maximal Square: lc 221. 
Delete and Earn: lc 740. similar to house robber.
Dungeon Game: lc 174.  this is special because dp direction is different from other questions. 
Longest Valid Parentheses: lc32

记忆化搜索（memorization):
Longest Increasing Continuous subsequence II: (结合了dfs和dp， 帮助理解dp如何在搜索的过程中去重，大大降低算法的时间复杂度。）此题只有记忆
化搜索才能最优化。
https://algorithm.yuanbin.me/zh-hans/dynamic_programming/longest_increasing_continuous_subsequence_ii.html
Longest Increasing Path in a Matrix:lc 329! (自己写的模板，复习时候看!)
Combination Sum IV:lc377 这道题题目类似于背包问题，但是由于顺序不同，结果也不同，所以难以写出递推公式，用memorization却能轻易解决。
K sum:  https://www.lintcode.com/problem/k-sum/description   (最经典memorization问题。 先考虑divide conquer，然后考虑dp数组应该怎么
表示， 画图可以找到重复的部分）

什么时候用记忆化搜索? 
1. 状态转移特别麻烦，不是顺序性。
2. 初始化状态不是很容易找到。
 
博弈dp：用搜索的角度去找状态之间的关系 (可以用memorization 写，也可以用普通写法）。
this.coin in the line |, ||

区间型dp: 
Stone game: https://www.lintcode.com/submission/14709621/
Burst Balloons: lc 312 (注意for循环的顺序，是个套路）
Palindromic Substrings: lc647
Longest Palindromic Substring: lc5 (这道题只有设成区间型(i,j)，才能写出递推公式）

匹配型dp: input is almost two string. 
this. longest common subsequence
Edit Distance: lc 72
Distinct Subsequences: lc 115 
Interleaving String: lc 97(未完成）
a trick for writing code is that if input is string, the length of dp array should be str.length+1;

背包类dp：
Coin Change: lc322 lc518
Ones and Zeroes: lc474

backpack:  https://www.lintcode.com/problem/backpack/description
记住save space complexity的模板：
    public int backPack(int m, int[] A) {
        // write your code here
        if(m==0 || A==null || A.length==0)
            return 0;
        int l=A.length;
        int[] dp = new int[m+1];

        int temp;
        for(int i=1;i<=l;i++){
            for(int j=m;j>=1;j--){  //从后往前，可以画出矩阵来看，记住！！
                if(j-A[i-1]>=0)
                    dp[j]=Math.max(A[i-1]+dp[j-A[i-1]],dp[j]);
            }
        }
        return dp[m];
    }



大类型DP（自己总结）: 如果只和上一个状态有关系，怎么space complexity可以降低为O(1)
Best Time to Buy and Sell Stock:

T[i][k][0](ending in ith index and at most k!!!(at most is important) transaction ending in 0 stock),  
T[i][k][1] (ending in ith index and at most k!!!(at most is important) transaction ending in 1 stock);
Base cases:
T[-1][k][0] = 0, T[-1][k][1] = -Infinity
T[i][0][0] = 0, T[i][0][1] = -Infinity

Recurrence relation:
T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])
T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i])

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870



some tricks:
1,for Continuous Subarray Sum problem, dp may cause memory limit problem. So instead here we can compute presum first.
Ex: Continuous Subarray Sum: lc523


