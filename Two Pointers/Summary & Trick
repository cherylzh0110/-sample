
同向双指针：
Two Sum - Difference equals to target  
https://www.lintcode.com/submission/14497657


相向双指针：
1，Two sum quesions and its follow up:   two sum is the two pointers in different directions.
Basic two sum:
two pointer method:   https://www.jiuzhang.com/solutions/two-sum/
hashmap method: leetcode 1
Note: -For sorted array: use two pointer can save extra space;
      -For unsorted array: use hashmap will only cost O(n), take O(n) extra space. Two pointer will cost O(n)
follow up: Two Sum Closest: 比two sum多出来的地方就是在过程中要记录一下difference。 看this. two sum questions

3SUM: leetcode 15 (make use of 2SUM, difficult part is remove duplicate)
follow up: 3SUM closest: leetcode 16

4SUM: lc18 (make use of 2SUM and 3SUM, should remove duplicate in all functions.)

2.Valid Triangle Number: leetcode 611  trick is (for the sorted array, we just need to consider whether a+b>c! that's enough)


3，Partition Array:

example: 
this.partition array.java
quick sort: this.quick sort
quick select: this.quick_select        https://www.lintcode.com/problem/kth-smallest-numbers-in-unsorted-array/my-submissions

3, Sort
this.quick sort
this.rainbow sort: combine of quick sort and merge sort!


4.For most substring problem, we are given a string and need to find a substring of it which satisfy some restrictions. A general way is to use a hashmap assisted with two pointers. The template is given below.
there is a template

  for(int right=0;right<s.length();right++){

            if(map[s[end++]]-- ?){  /* modify counter here */ }

            while(/* counter condition */){ 
                 
                 /* update d here if finding minimum*/

                //increase begin to make it invalid/valid again
                
                if(map[s[begin++]]++ ?){ /*modify counter here*/ }
            }  

            /* update d here if finding maximum*/
        }
 
 ex: Minimum Window Substring lc 76   //this question is the pointer in the same direction. It's like a window.
        
